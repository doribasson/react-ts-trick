Clusre and scope

Clusre
זה function along with its lexicale scope bundle together from a clusre.
זאת אומרת שהמשתנה שהוגדר מחוץ לסקופ  אוטומטי הוא יהיה זמין בתוך הסקופ הפנימי בלי שנצטרך להעביר אותו.
לפונקציה הפנימית יש גישה למשתנים של הפונקציה החיצונית.
זאת אומרת שאם יש לי פונקציה ובתוכה פונקציה פנימית אחרת שזה יכול להיות גם callback  אז לפונקציה הפנימית הזאת יש clusre שזה אובייקט שיש בתוכו את כל המשתנים למשל 
let i=2
של הפונקציה החיצונית שעוטפת את הפונקציה הפנימית וככה נוכל להשתמש במשתנים האלה.
בתוך הקלוזר יהיו רק משתנים שהגדרנו בפונקציה החיצונית ומשתמשים בפונקציה הפנימית. אם לא נשתמש במשתנים האלה בפונקצית הפנימית אז  לא יופיע בקלוזר.

שיטה פחות טובה הייתה לעשות משתנה גלובלי מחוץ לפונקציה ולהשתמש בו. היא פחות טובה כי אפשר לשנות אותו מכל מקום לכן נעדיף תמיד לעטוף אותו בפונקציה חיצונית ופנימית וככה הוא יהיה שייך רק לפונקציה הספציפית הזאת ולא לכל התוכנית.

Scope
בלוק שבתוכו יש משתנים.
בתוך בלוק או פונקציה המשתנים let ו const יוגדרו תמיד הכי למעלה כי למשל אם הם יוגדרו מתחת והשימוש יהיה למעלה אז לא יהיה להם גישה לזכרון וזה יהיה שגיאה. לעמת  ;var a הוא כן יכיר בזכרון כי הוא נמצא בזכרון אחר שנקרא גלובל אבל הוא יגדיר את המשתנה a undefined כי עדיין לא הגדרנו לו את הערך. אם למשל לא הגדרנו את b  ונרצה לעשות שימוש ב b אז ירשום שגיאה not find שבכלל הוא לא מוצא אותו.
ב var כל רמה מעל שגם יש var עם אותו משתנה והגדרה אז הוא בעצם ישתמש בהגדרה שהכי קרובה אליו בבלוק זאת אומרת ברמה שלו. אם אין בבלוק שלו את ההגדרה אז הוא יבדוק ברמה מעל וישתמש בה וכך הלאה.
let ו const 
שייכים לסקופ שהם נמצאים בו בלבד אבל ההבדל בניהם ש const חייב אתחול בהגדרה זא ישר לתת לו השמה התחלתית ו let לא זא אפשר להגדיר את ה let ואז בהמשך לעשות השמה. למשתנה של ה let.
 דבר נוסף הוא ש const הוא קבוע וברגע כשהגדרנו אותו לא ניתן לשנותו.
את ה let כן ניתן לשנות את ערכו.

תמיד נעדיף להשתמש קודם ב const שהוא הכי מחמיר ואז רק ב let ולבסוף רק ב var שעדיף בכלל להימנע ממנו.
וזה בגלל שזה יכול לחסוך לנו שגיאות ובאגים לא רצויות.  ותמיד יהיה לנו מעקב עליהם בסקופ. כי אם נעשה var ו var אנו יכולים לשנות מכל מקום אז זה יכול ליצור באגים ושינויים של דברים.


Hoisted
איך משתנים בסקופ עובדים.
אם לא ניצור משתנה ונעשה קונסול לוג למשתנה אז אז ירשום not undefined גם ב let..var...const ותהיה שגיאה ארור ויצא מהתוכנית.
אם כן הגדרנו משתנה למשל והוגדר כ var למשל  var a והקונסול לוג יהיה מעליו אז המשתנה יוגדר כ undefined ולא יהיה ארור. אם זה let או const אז תהיה שגיאה שאין גישה לפני האתחול.
אם הקונסול לוג יהיה אחרי היצירה אז ב var a יהיה undefined כי לא עשינו לו השמה ו let גם undefined אם במידה ולא עשינו גם לא השמה. אם כן היה השמה אז היה נותן לנו את התוכן של ההשמה הקונסול לוג גם ב var ..const..let.

אם אנחנו בפונקציה והמשתנים מעליו אז אותו דבר יקרה. זאת אומרת הוא עולה לרמה שמעליו ובודק אם יש משתנים כאלה ומציג את התוכן אם יש אם הם קיימים ואין להם השמה אז ההשמה תהיה undefined. אם אנחנו נשים בפונקציה את אותו משתנה כמו שהגדרנו מעל הפונקציה אז אז הוא יתן לנו את זה שאנחנו עליו זאת אומרת את ההשמה החדשה ולא את ההשמה של זה מעל הפןנקציה. זאת אומרת הוא הסתיר לנו את מה שמעל הפונקציה.

מותר שיהיה var a עם אותו שם כמה פעמים והוא יקח את האחרון. אבל ל let ו const אסור שיהיה את אותו שם כי יתן שגיאת קומפילציה.

עם הטיפוסים המשתנים מעל ההפעלה של הפונקציה אז יעבוד כרגיל יציג את התוכן או undefined אם לא עשינו השמה גם ל var וגם ל let.

עם הטיפוסים המשתנים מתחת להפעלה של הפונקציה אז הוא לא יכיר את ה let גם אם עשינו ל let השמה וגם אם לא. ירשום שגיאה שאין גישה למשתנה לפני האתחול.
אבל אם יש var ולא let  אז יוגדרו כ undefined ולא תהיה שגיאה.

אם יש var a בלי השמה ומתחתו קונסול לוג a אז יהיה undedined.
אם יש var a ומתחתו הפעלת פונקציה שבתוך הפונקציה הוא עושה a = 5 אז אם יש קונסול לוג a בתוך הפונקציה הוא יציג 5 ואז יש קונסול לוג מחוץ לפונקציה מתחת להפעלה של הפונקציה אז יציג את השינוי החדש שזה 5.
אם זה היה var a = 5 ולא  a=5 אז הוא יראה את העדכון רק בפונקציה כי יצר משתנה חדש וכשיצא מהפונקציה הוא יהיה מה שהיה בהשמה הקודמת לפני שנכנס לפונקציה. זה יצר משתנה a חדש  ככה שהוא לא דרס את ה a הקודם.

נזכור שמשתנים כמו var ופנוקציות נשמרים בגלובל ספייס. ה var יאותחל בהתחלה הראשונית ל undefined גם אם יש בו השמה למספר עדיין יהיה אנדיפיינד וזה קורה בגלל שבהתחלה נשמרים כל המשתנים וכל הפונקציות עוד לפני שהתחלנו להריץ.  כל הפונקציות יהיו בדיוק אותו דבר ולא undefined עושה העתקה שלהם כמו שהם לגלובל.




סְגוֹר מאפשר לפונקציה לגשת למשתנים שהם מחוץ לטווח-ההכרה הלקסיקלי המידי שלה. כלומר, משתנים שאינם מוגדרים בפונקציה הנוכחית, וגם אינם משתנים גלובליים.


￼

Codehub

￼

JAVASCRIPT

Javascript: מה זה Closure ולמה אני חייב לדעת מה זאת סביבה לקסיקלית

￼

על ידי

מני אדרי

פורסם בתאריך 16 באוקטובר 2018

שפת Javascript באופן מסויים היא שפה שמונחת פונקציות, היא נותנת לנו חופש לעשות עם פונקציות ככל העולה על רוחינו. ברגע אחד אתה יוצר פונקציה ברגע אחר אתה מעתיק את הפונקציה למשתנה או מעביר את הפונקציה כארגומנט לפונקציה אחרת ובסופו של דבר אתה מפעיל את הפונקציה במקום שונה לגמרי.

Closures הוא אחד מהנושאים שפתאום יקפצו ברוב ראיונות העבודה למשרות Javascript, כשאני מראיין מפתחים ומנסה לבדוק שליטה בסיסית בשפה, השאלה על Closures עולה מהר מאוד בתחילת הראיון ופתאום אני מגלה שלא הרבה מפתחים מבינים באמת במה מדובר או שקשה להם להסביר הנושא בצורה טובה.

נושא ה-closures יכול להיות מוסבר בצורה מפחידה ואפשר להתבלבל ולחשוב שמדובר בקונספט מסובך, אבל לא כך הדבר, תנו לי להוכיח לכם באמצעות 6 שורות פשוטות:

function iAmYourFather() { let x = 2 return function iAmYourSon(y) { return x * y } }

והנה לפניכם closure קצר וקלאסי שבטח רשמתם כמה פעמים, אז מה בעצם ההגדרה של closure (או בעברית סְגוֹר)?

סְגוֹר היא פונקציה יחד עם סביבת ייחוס עבור המשתנים שאינם מקומיים בפונקציה.

סְגוֹר מאפשר לפונקציה לגשת למשתנים שהם מחוץ לטווח-ההכרה הלקסיקלי המידי שלה. כלומר, משתנים שאינם מוגדרים בפונקציה הנוכחית, וגם אינם משתנים גלובליים.

מתוך וויקיפדיה

אפשר להבין אם זה נשמע לא מובן או מסובך מידי לחלקכם, אבל אחרי שתסיימו לקרוא את המאמר אתם תוכלו לא רק להסביר בצורה פשוטה מה הוא closure אלא באמת להבין ולהפוך למתכנתים טובים יותר. יאללה מתחילים.

סביבה לקסיקלית

ב-JavaScript כל פונקציה, בלוק של קוד או אפילו לקוד שנמצא ברמה הכי גבוהה יש מן אובייקט מיוחד ופנימי אשר נקרא Lexical Environment (או בעברית סביבה לקסיקלית) אשר מתחלק לשני חלקים:

Environment Record – אובייקט שמכיל בתוכו את כל המשתנים המקומיים כ-properties (ודברים נוספים כמו הערך של this).

הפנייה לסביבה הלקסיקלית החיצונית (זאת שמעליו בהיררכיה), בדרך כלל הכוונה לקוד שנמצא מחוץ לפונקצייה (מחוץ לסוגריים הנוכחיים).

עכשיו אנחנו מבינים שמשתנה הוא בסך הכל property בתוך אובייקט פנימי מיוחד שנקרא Environment Record. כשאנחנו אומרים ״לשנות משתנה״ זה בעצם ״לשנות property של ה-Environment Record"!.


function makeCounter() { 
let count = 0; 
return function() { 
return count++;
 } } 
let counter = makeCounter(); // בדוגמא זו הפונקציה counter רצה בסביבה הלקסיקלית הגלובילית באופן תקין, למרות שהיא נוצרה בתוך makeCounter!
 alert( counter() ); // 0 alert( counter() ); // 1 alert( counter() ); // 2

בדוגמא זו הפונקציה makeCounter יוצרת ומחזירה פונקציה אנונימית שהיא בעצם ה-״counter״ שלנו, ומה שהפונקציה האנונימית עושה היא מחזירה את המספר הבא בכל קריאה, כשהפונקציה האנונימית  רצה היא מחפשת את המשתנה count בסביבה הלקסיקלית שלה היא כמובן לא מוצאת אותו אז היא עולה רמה לסביבה הלקסיקלית שמעליה ושם היא כמובן מוצאת אותו ומעלה את הערך במשתנה בסביבה הלקסיקלית שלו.

Closure הוא מצב שבו פונקציה מסוגלת ליזכור ולגשת לסביבה הלקסיקלית שבה היא נוצרה אפילו אם הפונקציה רצה מחוץ לה

שאלות להעשרת הידע

שאלה: האם אנחנו יכולים בשלב מסויים לאפס את המשתנה count?

תשובה: לא, אין גישה מבחוץ למשתנים פנימיים.

שאלה: אם אנחנו קוראים כמה פעמים לmakeCounter היא תחזיר לנו כמה פונקציות אנונימיות. האם הן עצמאיות או שכולן חולקות את אותו משתנה count?

תשובה: בכל קריאה לmakeCounter חוזרת אלינו פונקציה חדשה, כך שהתשובה היא שהפונקציות עצמאיות ולא חולקות את אותו המשתנה.

https://codehub.co.il/2018/10/16/%D7%9E%D7%94-%D7%96%D7%94-closure-%D7%95%D7%9C%D7%9E%D7%94-%D7%90%D7%A0%D7%99-%D7%97%D7%99%D7%99%D7%91-%D7%9C%D7%93%D7%A2%D7%AA-%D7%9E%D7%94-%D7%96%D7%90%D7%AA-%D7%A1%D7%91%D7%99%D7%91%D7%94-%D7%9C/