איבנטלופ - לולאה שעובדת קבוע ובודקת אם יש משהו בתור של
 task/callback queue
ששם זה setTimeout  או setinterval eventlistner click

או בתור של
MicroTask queue
ששם זה fetch או observable- מאפשר להזרים מידע ולשנות ברגע שמשהו התרחש.

יש עדיפות לתור של MicroTask queue מאשר לתור של task/callback queue.

ורק אם ה - call stack ריק אז יעביר את האיבנט מאחד התורים עם עדיפות שכל האיבנטים של MicroTask queue בעדיפות קודם ורק שיסיים את כל האיבנטים שם אז יעבור לאיבנטים של
 task/callback queue
    ואז יבצע את כל האיבנטים שם.

יש קוד והקוד רץ שורה אחר שורה ומתבצעת למעט אם יש בדרך פונקציה כמו settimeout  או setinterval eventListner  או איבנט או fetch.
ואז מעביר אותם ל web api שזה בתוך הבראוזר שהוא יש לו טרד אחר משלו. וברגע שהם מוכנים הם עוברים לאחד התורים.
מוכנים אומר שאם זה למשל settimeout שהטיימר ייגמר אז יעבור לאיבנט של task/callback queue.
ואם זה איבנט של fetch אז ברגע שהקריאה הפרמיס תחזור מהסרבר הוא יעביר את זה MicroTask queue.

עכשיו רק ברגע שכל שורות הקוד שבסטק הסתיימו רק אז האיבנטים שבתור יכנסו אחד אחרי השני לסטק ואז יתבצע המימוש.
מתבצע כך שכל איבנט שנכנס לסטק עושה את המימוש שלו ואז נמחק מהסטק ואז איבנט שני נכנס לסטק עושה את המימוש שלו ואז נמחק מהסטק וכך לכל האיבנטים אחד אחרי השני.
כמו שאמרנו קודם יש עדיפות לאיבנטים של התור של הקריאות שמגיעות מהסרבר שזה MicroTask queue ורק; שהכל יסתיים ילך לתור של
task/callback queue

המעבר שכל האיבנטים מהתור לסטק קורה בעזרת האיבנט לופ  שעובד קבוע שזה לולאה קבועה  שלוקחת את האיבנט מהראשון שבתור ומכניסה אותו לסטק אך ורק אם הסטק ריק.


בתוך ה browser יש את ה webApi ששם יש לו כל מני שיטות ופקודות לדברים שקיימים בבראוזר. כמו למשל console.log.. localstorage..setTimeout .. setInterval..fetch. .. הגישה אליהם דרך  .windows למשל
windows.console.log(""llll");
Windows.localstorage.setItem...
windows.location...
Windows.domApi - document.getElmentById("class").
addEventIstner("click",function cb()"))

Fetch..
וכו..
אפשר להשמיט את המילה windows והוא עדיין ידע.

שאלה אחרת..
אם יש לי פור
for(var i=0; i<10; i++){
  setTimeout(() => {
    console.log(i)
    }, 0);
}
מה שיקרה זה הפור שזה בסטק ירוץ ובכל איטרציה הוא יכניס את ה setTimeout ל webApi שזה כבר שייך לבראוזר שיש לו טרד אחר שרץ ברקע ומאזין לקריאות כאלה שהם אסנכרוניות שלוקחות זמן ושם יהיה טיימר 0 ואז שהטיימר יסתיים הוא יכניס לתור של ה task queue. וזה קורה במקביל לקוד הסנכרוני שנכנס ומתממש על הסטק. 
רק ברגע שמסתיים כל שורות הקוד  שביצע -  כל הפקודות שהיו אחד אחרי השני על הסטק שאצלנו פה זה הפור, הוא עובר לתורים של האיבנטים שאצלנו זה התור task queue שבתוכו יש איבנט של setTimeout. האיבנט לופ שעובד קבוע לוקח אותו מהתור ומכניס  אותו לסטק ואז מבצע את הפקודה שלו.
אבל עד אז ה i האחרון הגיע ל 10 בפור ויש לנו 10 איבנטים שנכנסו לתור.
לכן ידפיס 10 פעמים 10. 
מה שקורה זה כל פעם ה i בפור זה אותו i את אומרת רפרנס לאותו i ולא משתנה חדש והi מצביע ל 10 אז הכל 10.
דרך לטפל בזה במקום var i=0 בפור נעשה let i=0 ואז כל i זה משתנה חדש ולא רק רפרנס ל i. וזה כי let הוא יוצר ממורי בלוק אחר כמו משתנה חדש.

דרך שניה לטפל בזה , זה דרך קלוזר, אחרי הפור לעטוף את כל ה setTimeout  בפונקציה ולהכניס לה את הפרמטר של i. ואז לזמן את הפונקציה ומה שיקרה זה בעצם יצור כל פעם ממורי חדש של הפונקציה עם אותו ה i.
