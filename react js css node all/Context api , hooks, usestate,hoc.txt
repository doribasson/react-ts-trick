Context api , hooks, usestate,hoc

Hoc- higher order conponent 
מאפשר לנו לעשות שימוש חוזר בקומפוננטה. בעצם מעבירים קומפוננטה כפרמטר לקומפוננטה החדשה. זא אפשר להציג את הקומפוננטה הישנה בתוספת לוקיגה חדשה ואלמנטים. זא יוצרים קומפוננטה שלוקחת כפרמטר קומפוננטה שאנו רוצים להרחיב ומחזירים בתוכה את הקומפוננטה שלקחנו כפרמטר עם הפרופס שלה ומוסיפים סטיטים או פונקציות להרחבה. ואז בקומפוננטה שאנחנו רוצים להכניס אליה את כל זה
נעטוף אותה בסוף זא
   export default useSample(Send)
useSample 
זאת הקומפוננטה שעטפה את הקומפוננטה שהרחבתי אותה.
ו send זאת הקומפוננטה הרגילה שנרצה שתכיל את השינויים האלה.
ברגע שקומפוננטה Send תפעל בהתחלה, היא תציג את הקמפוננטה ששלחנו כפרמטר עם השינויים.


Context api
מאפשר לנו להעביר פונקציות או סטייטים לקומפוננטה אחרת. 
Provider 
בעצם מכין את התשתית שזה הפונקציות והסטיטים.
ו consumer ישתמש בהם בקומפוננטה האחרת. ככה נוכל להעביר פונקציות וסטייטים בלי redux.


בהתחלה נעטוף את מה שאנחנו רוצים
 <SampleProvider> 
   <Search/>
    <Input/>
  </SampleProvider> 
זה ילך לקומפוננטה של SampleProvider.
שם נעשה createContex.
const SampleCtx = createContext({});
ואז ניצור
<SampleCtx.Provider         value={sampleContext}>    {props.children} 
</SampleCtx.Provider>
הצילדרן זה בעצם search ו input כולל האלמנטים שלהם.
ובשביל להשתמש
const sampleCtx = useContext(SampleCtx);  value={sampleCtx.value} setValue={sampleCtx.setValue} /> ); }

https://stackoverflow.com/questions/57782104/hoc-with-react-hooks


Hooks
תחליף לקלס.
נוכל לכתוב פונקציות. וסטייטים בעזרת usestate ולתת lifesycle ב useeffect
אם רוצים שזה ירנדר רק בפעם הראשונה נכתוב את זה עם מערך אחרת לא. אם נרצה שירנדר אחרי כל עידכון של הסטייט אז נרשום בתוך המערך את הסטייט עצמו.

יש React memo ויש useMemo ויש useCallback
ריאקט ממו - אם נרצה להעביר פרופס מהאבא לילד אבל נרצה שהוא ירנדר רק מתי שהפרופ שהעברנו באמת השתנה. הוא יעבוד רק אם סטרינג ועם נמבר לא יעבוד עם נעביר אובייקט או מערך או פונקציה. בגלל שהם מועברים בי-רפרנס ולא בי-וואליו. זאת אומרת שהוא ירנדר בכל זאת את הקומפוננטה כי בשבילו הפרופ נוצר מחדש כי זה אובייקט.
בשביל לפתור את הבעיה הזאת נשתמש ב useMemo-
יוז ממו - אפשר בעצם ליצור משתנה שהוא אובייקט שיעטוף את הפרופ שאנחנו רוצים שהוא יחזיר ובמערך הדפנדסי נרשום את אותם הפרופס בשביל שהוא יתרנדר רק מתי שאחד מהפרופס משתנה. דבר נוסף נרצה את היוזממו מתי שהפונקציות מורכבות ודורשות הרבה משאבים וזמן ככה שזה לא יתבצע כל פעם אלא רק שמשהו מהדפנדסי משתנה אז הפונקציה תפעל.
יוזממו  מביא לפתרון של אובייקט ושל מערך כי מועברים בי-רפרנס  מה שריאקט-ממו לא כי מביאה לפתרון של סטרינג ונמבר.
נותנים לנו בעצם שליטה בכך שנוכל לא לרנדר דברים שאנחנו לא רוצים יותר מפעם אחת או לפי תנאי.

יוזקולבק- זה אם נרצה למנוע מפונקציה לפעול להתרנדר ולהיווצר בלי קשר בפרופ.
ברגע שהאבא מתרנדר אז הבן מתרנדר וגם אם לבן שלחתי פונקציה כפרופ למשל או לשלוח פונקציה עם קולבק שמשנה את הסטייט אז בעצם הוא יצור את הפונקציה כל פעם מחדש
ואנחנו לא רוצים. אנחנו רוצים שיצור רק אם היה שינוי זאת אומרת אם מה ששמתי במערך של הדפנדסי שלו השתנה.

React memo
בשביל ביצועים. מתי שאנחנו עושים אפדייט לסטייט אז יש רנדור. בעצם הוא מרנדר את כל הקומפוננטות וזה פוגע בביצועים כי מה שהיינו רוצים זה לרנדר רק את מה ששיננו ולא את הכל. אז ה memo עוזר לנו שהוא בעצם higher order conponent. הוא אומר אם רק היה שינוי של סטייט או פרופס רק אז תרנדר. בסוף הקומפוננטה. 
export default React.memo(ChaildComponent)
הריאקט ממו נשים בתוך הילד ולא האבא. ומה שעובר
זה אומר שאם יש לי הורה ובתוכו ילד ואני לא רוצה שהילד יתרנדר סתם אחרי כל שינוי שקורה אצל האבא אלא רק מתי שהפרופס שעובר מהאבא לילד משתנה אז  הילד יתרנדר מחדש. זה לא יעבוד על מערך ואובייקט ופונקציות לכן נשתמש בפונקציות ביוזקולבק , ולמערך ואובייקט נשתמש ביוז ריאקט.

אבל אם נגיד יש לי פונקציה שמעדכנת סטייט ולא נרצה שהיא תעדכן גם את השאר אז פה נכנס ה useCallback שזה פונקציה בתוך ריאקט שמממשת בתוכה את העדכון של הסטייט ובסוף חתימת הפונקציה יש מערך שבתוכו נרשום את סטייט שרק במידה אם השתנה אז הפונקציה תתרנדר אחרת תשאר אותו הדבר.

UseHistory אני יכול לנתב לנתיב אחר בדף  עי const history=useHistory
history.push(...)

UseParams 
במקום לקבל כפרופס את match ואז 
match.params.name
אפשר להשתמש ב ()useParams בתוך ריאקט ראוטר.
const {firstname} = useParams()
ואז להשתמש בו. מי שדואג להעביר את הפרמ הזה מהנתיב דרך match זה useParams מאחורי הקלעים.
בעצם מה שזה עושה זה לוקח מתוך route שהפנה אותו את הפרמטר של id:
מ patch .אם אני רוצה להגיע למוצר ספציפי למשל ..Location.state.name

window.location or useLocation מתוך ריאקט ראוטר
אובייקט שמכיל בתוכו כמה דברים כמו הנתיב עצמו. hash שזה lala# תחילת הסולמית בנתיב. אם מופיע search אז משם אפשר להכניס לו פרמטר שיחפש למשל. או אם העברנו ב Route סטייט אז אפשר לקבל אותו פה.

ב Route נשים exect שזה כמו exect=true בשביל שלא יכלול את כל מה שמתחיל באותו נתיב. למשל 
/user
/user/:id
שניהם מתחילים ב user אז הוא בעצם יראה את שניהם ואנחנו רוצים את אחד מהם. 
switch
שרק נתיב אחד נראה ולא יהיה מצב שנראה את שני הקומפוננטות ביחד.


const urlParams= new URL(url).search;
 יביא לי את כל מה שאחרי הסימן שאלה בנתיב ואם נרצה את הפרמטר אחרי השווה נעשה [1]("=")split יביא לנו את הפרמטר אחרי השווה. למשל:
localhost:3000/cart/1?qty=3
יביא לנו את 3. כי הספליט נותן מערך שמפצל לנו לפי השווה ולכן יהיה שני תאים במערך התא הראשון מהתחלה ועד השווה לא כולך והתא השני זה 3. 
השווה יעלם.